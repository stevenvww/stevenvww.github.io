<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>stevenv的学习笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://stevenvww.github.io/"/>
  <updated>2020-01-10T10:30:13.517Z</updated>
  <id>https://stevenvww.github.io/</id>
  
  <author>
    <name>stevenv</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>InnoDb-Architecture</title>
    <link href="https://stevenvww.github.io/2019/06/19/Innodb-Architecture/"/>
    <id>https://stevenvww.github.io/2019/06/19/Innodb-Architecture/</id>
    <published>2019-06-19T07:15:34.000Z</published>
    <updated>2020-01-10T10:30:13.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="InnoDB-In-Memory-Structures"><a href="#InnoDB-In-Memory-Structures" class="headerlink" title="InnoDB In-Memory Structures"></a>InnoDB In-Memory Structures</h1><h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><blockquote><p>Buffer Pool 是内存中的一块区域，用于缓存表和索引的数据。通过将频繁访问的数据存储在此</p></blockquote><ul><li>为了加快处理速度，Buffer Pool 允许直接从内存处理常用数据。并且在专用服务器上，高达80%的物理内存都分配给 Buffer Pool。</li><li>为了提高大容量读取操作的效率，Buffer Pool 按页划分，每页可以存储多行。</li><li>为了提高缓存管理的效率，InnoDB 管理 Buffer Pool 使用了 LRU 算法，该算法是用链表实现的。</li><li>Buffer Pool 通过使用变种的 LRU 算法，保证很少被使用缓存及时被移除。</li></ul><h2 id="Buffer-Pool-LRU-Algorithm"><a href="#Buffer-Pool-LRU-Algorithm" class="headerlink" title="Buffer Pool LRU Algorithm"></a>Buffer Pool LRU Algorithm</h2><blockquote><p>LRU(Least Recently Used) 算法，中文叫做最近最少使用算法，这个算法的核心就是淘汰最久未使用的数据。</p></blockquote><h3 id="1、基本的-LRU-算法"><a href="#1、基本的-LRU-算法" class="headerlink" title="1、基本的 LRU 算法"></a>1、基本的 LRU 算法</h3><img src="/2019/06/19/Innodb-Architecture/基本的LRU算法模型.jpg" title="图1:基本的LRU算法模型"><p>LRU 算法是用链表来实现的。</p><ul><li>图 1 的 state1 里，链表的头部是P1， 表示刚刚被访问的数据页。并且假设内存只能放下这么多数据</li><li>然后有一个读请求要访问 P3 数据页，因此变成 state 2，P3 被移到头部。</li><li>state 3 表示，这次访问的数据页是不存在于链表中的，所以需要在 Buffer Pool 中新申请一个数据页 Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾 Pm 这个数据页的内存，存入 Px 的内容，然后放到链表头部。</li><li>所以最久未访问的数据页被移除了。</li></ul><p>假设按照这个算法，要全表扫面一个 200G 的表，而这个表是历史数据表，平时没有业务访问它。</p><p>那么按照这个算法扫描的话，就会把当前 Buffer Pool 里数据全部淘汰掉，存入扫描过程中访问到的数据页内容，也就是说 Buffer Pool 里面主要放的是这个历史数据表的数据。</p><p>对于一个正在做业务服务的库，十分不妙。Buffer Pool 的内存命中率会急剧下降，磁盘压力增大，SQL 语句响应变慢。</p><p>所以 InnoDB 不能直接使用这个 LRU 算法，实际上，InnoDB 对 LRU 算法做了改进。</p><h3 id="2、改进的-LRU-算法"><a href="#2、改进的-LRU-算法" class="headerlink" title="2、改进的 LRU 算法"></a>2、改进的 LRU 算法</h3><img src="/2019/06/19/Innodb-Architecture/改进的LRU算法模型.png" title="图2:改进的LRU算法"><p>InnoDB 按照 5:3 的比例把整个 LRU 链表分为了 young 区域和 old 区域。图中 LRU_old 指向的就是 old 区域的第一个位置，是整个链表的 5/8 处。也就是说靠近链表头部的 5/8 是 young 区域，靠近链表尾部的 3/8 是 old 区域。</p><ul><li>图 2 中的 state 1，要访问数据页 P3，由于 P3 在young 区域，因此和优化前的 LRU 算法一致，将其移到头部，编程 state 2。</li><li>之后要访问一个新的不存在当前链表的数据页，这时候依然是淘汰掉数据页 Pm，但新插入的数据页 Px，放在 LRU_old 处</li><li>处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：<ul><li>若这个数据页在 LRU 链表中存在的时间超过了 1s，就把它移动到链表头部；</li><li>若这个数据页在 LRU 链表中存在的时间短于 1s，位置保持不变。1s 这个时间，由参数 innodb_old_blocks_time 控制的。其默认值是 1000，单位毫秒。</li></ul></li></ul><p>这个策略，就是为了处理类似全表扫描的操作量身定制的。以扫描 200G 的历史数据表为例，改进后的 LRU 算法的操作逻辑如下：</p><ul><li>扫描过程中，需要新插入的数据页，都被放到 old 区域；</li><li>一个数据页有多条记录，这个数据页会被多次访问到，但由于是顺序扫描，这个数据页第一次被访问和最后一次被访问的时间间隔不会超过 1s，因此会被保留在 old 区域；</li><li>再继续扫描后续的数据，之前的这个数据页之后也不会再被访问到，于是始终没有机会移到链表头部 (也就是 young 区域)，很快就会被淘汰出去。</li></ul><p>所以这个策略最大的收益，就是在扫描大表的过程中，虽然也用到了 Buffer Pool， 但是对 young 区域完全没有影响，从而保证了 Buffer Pool 响应正常业务的查询命中率。</p>]]></content>
    
    <summary type="html">
    
      关于InnoDB结构的知识
    
    </summary>
    
    
    
      <category term="MySQL学习笔记" scheme="https://stevenvww.github.io/tags/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>order_by执行流程</title>
    <link href="https://stevenvww.github.io/2019/04/09/order-by%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://stevenvww.github.io/2019/04/09/order-by%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2019-04-09T02:46:00.000Z</published>
    <updated>2020-01-10T10:30:13.533Z</updated>
    
    <content type="html"><![CDATA[<p>假设有个表如下定义：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLE <span class="symbol">`t`</span> (</span><br><span class="line"><span class="symbol">`id`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="symbol">`city`</span> varchar(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="symbol">`name`</span> varchar(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="symbol">`age`</span> int(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="symbol">`addr`</span> varchar(<span class="number">128</span>) DEFAULT <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="symbol">`city`</span>(<span class="symbol">`city`</span>)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><p>此时有条 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span> ;</span><br></pre></td></tr></table></figure><p>执行这条 SQL 语句可能存在两种排序，分别是全字段排序和 rowid 排序。</p><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>为避免全表扫描，需要在 city 字段增加索引。<br>explain 命令查看这个语句的执行情况。</p><img src="/2019/04/09/order-by执行流程/explain.png" title="图1使用explain命令查看语句执行情况"><p>根据执行情况发现，Extra 字段中到”Using filesort”表示排序，MySQL 会给每一个线程分配一块内存进行排序，称为 sort_buffer。</p><p>语句执行流程：</p><ol><li>初始化 sort_buffer，确定放入 name、city、age 字段；</li><li>从索引 city 找到第一个满足 city=’杭州’ 的主键；</li><li>到主键 id 取出整行，取 name、city、age 这三个值，存入 sort_buffer 内；</li><li>从索引 city，取下一个主键 id；</li><li>重复步骤3、4，直到不满足查询条件为止；</li><li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li><li>按照排序结果前 1000 行返回给客户端。</li></ol><img src="/2019/04/09/order-by执行流程/全字段排序示意图.jpg" title="全字段排序示意图"><p>以上称为<strong>全字段排序</strong>，图中排序的动作可能在内存排序，也可能需要使用外部排序，这取决于排序所需要的内存和参数 sort_buffer_size。</p><p>sort_buffer_size 是 MySQL 为排序开辟的内存的大小。如果排序的数据量大于 sort_buffer_size，排序就在内存中完成，否则不得不利用磁盘临时文件辅助排序。</p><h4 id="确认排序是否使用临时文件的方法"><a href="#确认排序是否使用临时文件的方法" class="headerlink" title="确认排序是否使用临时文件的方法"></a>确认排序是否使用临时文件的方法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>;</span><br><span class="line"><span class="comment">/* @a 保存 Innodb_rows_read 的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, <span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* @b 保存 Innodb_rows_read 的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 计算 Innodb_rows_read 差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;</span><br></pre></td></tr></table></figure><p>这个方法通过查看 optimizer_trace 的结果来确认的，可以从 number_of_tmp_files 中查看是否用了临时文件。</p><img src="/2019/04/09/order-by执行流程/全排序的OPTIMIZER_TRACE部分结果.png" title="全排序的 OPTIMIZER_TRACE 部分结果"><p>number_of_tmp_files 表示的是，排序过程中使用的临时文件数。内存放不下的时候，就需要外部排序，外部排序一般采用归并排序。<strong>MySQL 将需要排序的数据分为 12 份，每一份单独排序后存在这些临时文件中。然后将12个有序文件再合成一个大的有序文件。</strong></p><p>如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。</p><p>否则就需要放在临时文件中排序。sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。</p><p>examined_rows=4000，表示参与排序的行数是4000行。</p><p>sort_mode 里面的 packed_additional_fields 的意思是排序过程中对字符串做了“紧凑”处理，即使 name 字段的定义是 varchar(16) ，在排序过程中还是要按照实际长度来分配空间的。</p><p>这里需要注意的是，为了避免对结论造成干扰，亿把 internal_tmp_disk_storage_engine 设置成 MyISAM。否则，select @b-@a 的结果会显示为 4001。</p><p>这是因为查询 OPTIMIZER_TRACE 这个表时，需要用到临时表，而 internal_tmp_disk_storage_engine 的默认值是 InnoDB。如果使用的是 InnoDB 引擎的话，把数据从临时表取出来的时候，会让 Innodb_rows_read 的值加 1。</p><h3 id="rewid-排序"><a href="#rewid-排序" class="headerlink" title="rewid 排序"></a>rewid 排序</h3><p>全字段排序只对原表读了一遍，剩下的操作都在 sort_buffer 和临时文件执行。因此有个问题，如果查询要返回的字段很多的话，那么 sort_buffer 里放的字段太多，同时能容纳的行数就很少，要分成很多个临时文件，排序性能就很差。</p><p>所以单行过大，效率就不好。那么如果单行过大，MySQL应该怎么处理呢？</p><p>可以通过修改参数，让 MySQL 换一个算法。<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data <span class="comment">= 16</span></span><br></pre></td></tr></table></figure></p><p>max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数(默认值为1024)。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p><p>city、name、age 这三个字段的定义总长度是 36，把 max_length_for_sort_data 设置为 16，则新的算法放入 sort_buffer 排序的字段只有 name 和 主键 id。</p><p>由于排序结果少了 city、name 字段，就不能直接返回了。因此整个执行流程变成以下这个样子：</p><ol><li>初始化 sort_buffer，放入 name、id 字段；</li><li>从索引 city 找到第一个满足 city=’杭州’ 的主键；</li><li>到主键 id 取出整行，取 name、id  这两个值，存入 sort_buffer 内；</li><li>从索引 city，取下一个主键 id；</li><li>重复步骤3、4，直到不满足查询条件为止；</li><li>对 sort_buffer 中的数据按照 name 排序；</li><li>遍历排序结果，取前 1000 行数据，并按照 id 值，从原表中取出 city、name 和 age 三个字段返回给客户端。</li></ol><p>这就是 <strong>rewid 排序</strong> ，示意图如下：<br><img src="/2019/04/09/order-by执行流程/rewid排序.jpg" title="rewid排序s"></p><p><strong>对比全字段排序，rewid 排序多访问了一次表的主键索引。</strong></p><p>“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到 city、name 和 age 这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p><h4 id="执行-select-b-a-的结果"><a href="#执行-select-b-a-的结果" class="headerlink" title="执行 select @b-@a 的结果"></a>执行 select @b-@a 的结果</h4><img src="/2019/04/09/order-by执行流程/rowid排序的OPTIMIZER_TRACE部分输出.png" title="rowid排序的OPTIMIZER_TRACE部分输出"><ul><li>examined_rows 还是 4000，表示排序的行数是 4000，但是 @b-@a的结果为 5000。</li><li>因为这时候除了排序，还去原表取了 1000 行，所以多读了 1000 行。</li><li>sort_mode 变成了 &lt;sort_key, rowid&gt;，表示参与排序的只有 name 和 id 这两个字段。</li><li>number_of_tmp_files 变成 10 了，是因为这时候参与排序的行数虽然仍然是 4000 行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。</li></ul><h3 id="全字段排序-VS-rewid-排序"><a href="#全字段排序-VS-rewid-排序" class="headerlink" title="全字段排序 VS rewid 排序"></a>全字段排序 VS rewid 排序</h3><p>如果 MySQL 担心内存太小，会影响排序效率，就会采用 rewid 排序。这样排序过程中一次可以排序更多行，但是需要去原表取数据。</p><p>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放在 sort_buffer 中，这样排序后直接从内存返回数据，不需要再去原表取数据。</p><p>这体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多使用内存，减少磁盘访问。</strong></p><p>对于 InnoDB 表来说，<strong>rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</strong></p><p><strong>可见 MySQL 排序是一个成本比较高的操作。但是并不是所有的 order by 语句都需要排序操作的。MySQL 只所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据是无序的。</strong></p><p>如果保证从 city 这个索引的行，天然保持按 name 字段递增排序，就可以不用再排序了。</p><p>如果在表上创建一个 city 和 name 的联合索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city, <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure></p><img src="/2019/04/09/order-by执行流程/city和name联合索引.png" title="city和name联合索引"><p>在这个索引中，依然可以使用树搜索的方式去定位到第一个满足 city=”杭州”的记录，并且确保了接下来按顺序去取下一条记录遍历中，只要 city 的值是杭州，name 就一定是有序的。</p><p>查询流程如下：</p><ol><li>从索引 (city,name) 找到第一个满足 city=’杭州’条件的主键 id；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name) 取下一个记录主键 id；</li><li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束</li></ol><img src="/2019/04/09/order-by执行流程/引入(city,name)联合索引.jpg" title="引入(city,name)联合索引"><p>可以看出这个查询，不需要临时表，不需要排序<br><img src="/2019/04/09/order-by执行流程/explain2.png" title="引入(city,name)联合查询explain执行计划"></p><p>从图中可以看到，Extra 字段中没有 Using filesort 了，也就是不需要排序了。而且由于 (city,name) 这个联合索引本身有序，所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了。也就是说，在我们这个例子里，只需要扫描 1000 次。</p><p><strong>利用覆盖索引继续优化</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city, <span class="keyword">name</span>, age);</span><br></pre></td></tr></table></figure></p><p>查询流程如下：</p><ol><li>从索引 (city,name,age) 找出满足第一个满足 city=’杭州’ 条件的记录，取出 city、name 和 age 三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分返回；</li><li>重复执行步骤 2，直到不满足条件或者查到第 1000 条记录为止。</li></ol><img src="/2019/04/09/order-by执行流程/引入(city,name,age)联合索引后，查询语句的执行流程.jpg" title="引入(city,name,age)联合索引后，查询语句的执行流程"><img src="/2019/04/09/order-by执行流程/引入(city,name,age)联合索引后，查询语句的执行计划.png" title="引入(city,name,age)联合索引后，查询语句的执行计划"><p>Extra 字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设有个表如下定义：&lt;/p&gt;
&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://stevenvww.github.io/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Count执行原理</title>
    <link href="https://stevenvww.github.io/2019/03/25/Count%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>https://stevenvww.github.io/2019/03/25/Count%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</id>
    <published>2019-03-25T03:46:00.000Z</published>
    <updated>2020-01-10T10:30:13.515Z</updated>
    
    <content type="html"><![CDATA[<p>不同的引擎有不同的实现方式：</p><ul><li>MyISAM 引擎把一个表的总行数放在磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。(如果加了过滤条件，也不能返回这么快)</li><li>InnoDB 引擎需要把数据一行一行的读取出来，然后累积计数。</li></ul><p>InonoDB引擎由于多版本并发控制的原因，每一行都要判断自己是否对这个会话可见，所以 InnoDB 表只能把数据一行一行读出依次判断。</p><p>MySQL 在执行 count(*) 的时候做了优化。InnoDB 是索引组织表，主键索引树的叶子结点是数据，而普通索引树的叶子结点是主键值。所以普通索引树比主键索引树小很多，因此 MySQL 优化器会找到最小的那颗树来遍历。<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</strong></p><p>除了 count(*)，使用 “show table status” 命令可以通过 TABLE_ROWS 拿到当前表总行数，但是这个字段是通过采样估算来的，不准确。</p><h2 id="统计计数的方法"><a href="#统计计数的方法" class="headerlink" title="统计计数的方法"></a>统计计数的方法</h2><h3 id="一、用缓存系统保存计数"><a href="#一、用缓存系统保存计数" class="headerlink" title="一、用缓存系统保存计数"></a>一、用缓存系统保存计数</h3><p>可以使用 redis 服务存储计数。但是用 redis 有两个问题。一是由于redis数据是存在内存里，异常重启可能会丢失更新；二是即使 redis 正常工作，这个值在逻辑上还是不准确的。</p><p>假设有一个页面，需要显示操作记录的总数，还要显示最近操作的一百条记录。那么这个页面需要先到 Redis 里面取出计数，再到数据表里面取出数据。</p><p>以下两种情况逻辑上必然不准确：</p><ol><li>查到的 100 行结果里面有最新插入的记录，而 Redis 的计数还没加1。</li><li>查到的 100 行结果里没有最新插入的记录，而 Redis 的计数已经加了1。</li></ol><img src="/2019/03/25/Count执行原理/redis不准确时序图.png" title="redis不准确时序图"><p>上图可以看出，会话 B 的读操作在T3时刻执行的，由于 redis 还没有加1，但是已经读到最新插入的记录，所以数据是不一致的。</p><p>在并发系统里面，无法精确控制不同线程的执行时刻，因为存在图中的这种操作序列，所以即使 Redis 正常工作，这个计数值还是逻辑上不准确。导致数据不一致的根本原因，<strong>是由于两个不同的存储系统构成的系统，不支持分布式事务，无法拿到精准一致的视图。</strong></p><p>所以如果要求计数值百分百准备，最好不要使用缓存系统保存计数。</p><h3 id="二、在数据库保存计数"><a href="#二、在数据库保存计数" class="headerlink" title="二、在数据库保存计数"></a>二、在数据库保存计数</h3><p>直接在数据库建一张计数表(InnoDB引擎)。首先InnoDB引擎可以支持崩溃恢复不丢失数据，然后利用 InnoDB 事务的特性可以解决数据不准确的毛病。</p><p>上图可以看到，会话 B 的读操作仍然是T3时刻执行的，但是因为这时候更新事务还没提交，所以计数+1对会话 B 还不可见。因此会话 B 看到的结果，查计数值和 “最近100条记录” 看到的结果逻辑上是一致的。</p><h2 id="不同的-count-的用法"><a href="#不同的-count-的用法" class="headerlink" title="不同的 count 的用法"></a>不同的 count 的用法</h2><p>count() 的语义。count() 是一个聚合函数，对于返回的结果集，一行一行地判断，如果 count 函数的参数不是 NULL， 累计值就加1，否则不加。最后返回累计值。</p><p>所以，count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数”字段”不为 NULL 的总个数。</p><p>分析性能差距的原则：</p><ol><li>server 层要什么给什么</li><li>InnoDB 只给必要的值</li><li>现在的优化器只优化了 count(*) 的语义为”取行数”，其他”显而易见”的优化并没有做。</li></ol><p><strong>对于 count(主键 id)</strong>。  InnoDB 会遍历整张表，把每一行的 id 拿出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p><p><strong>对于 count(1) 来说</strong>。InnoDB 会遍历整张表，但不取值。server 层对返回的每一行，放一个数字 1 进去，判断是不可能为空的，按行累加。</p><p><strong>对于 count(字段)</strong>。 </p><ul><li>如果这个字段定义为”not null”，一行行从记录里面读出这个字段，判断不能为 null，按行累加。</li><li>如果这个字段定义为”null”，那么执行的时候，判断有可能是 null，还要把值取出来再判断一下不是 null 才累加。</li></ul><p><strong>对于 count(*)</strong>。并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p><p> <strong>所以结论是：按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)，尽量使用 count(*)。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不同的引擎有不同的实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyISAM 引擎把一个表的总行数放在磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。(如果加了过滤条件，也不能返回这么快)&lt;/li&gt;
&lt;li&gt;InnoDB 引擎需要把数据一行一行的读取出来，然后
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://stevenvww.github.io/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据库表的空间回收</title>
    <link href="https://stevenvww.github.io/2019/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/"/>
    <id>https://stevenvww.github.io/2019/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</id>
    <published>2019-03-17T02:27:30.000Z</published>
    <updated>2020-01-10T10:30:13.548Z</updated>
    
    <content type="html"><![CDATA[<p>一个 InnoDB 表包含两部分，即：表结构定义和数据。MySQL 8.0 版本以前，表结构是存在以 .frm 为后缀的文件里，而 8.0 版本 已经允许把表结构定义放在系统数据表中了。</p><h3 id="为什么简单地删除表数据达不到表空间回收的效果"><a href="#为什么简单地删除表数据达不到表空间回收的效果" class="headerlink" title="为什么简单地删除表数据达不到表空间回收的效果"></a>为什么简单地删除表数据达不到表空间回收的效果</h3><h4 id="表数据存放在哪里"><a href="#表数据存放在哪里" class="headerlink" title="表数据存放在哪里"></a>表数据存放在哪里</h4><p>表数据可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：</p><ol><li>这个参数设为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</li></ol><p>从 MySQL 5.6.6 版本开始，它的默认值就是 ON。将 innodb_file_per_table 设为 ON 是推荐做法。因为，一个表单独存储为一个文件更容易管理，而且在不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果放在共享表空间中，即便表删掉了，空间也是不会回收的。</p><h4 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h4><p>InnoDB 里的数据都是用 B+ 树的结构组织的。如下图所示：</p><img src="/2019/03/17/数据库表的空间回收/B+树索引示意图.png" title="图1B+树索引示意图"><p>假设要删除图 1 中 R4 这个记录，InnoDB 引擎只会把 R4 这个记录标记为删除。如果之后再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p><p>由于 InnoDB 引擎的数据是按页存储的，如果我们删除一个数据页上的所有记录，整个数据页就可以被复用了。</p><p><strong>但是数据页跟记录的复用是不同的</strong></p><ul><li>记录的复用，只限于符合范围条件的数据。比如图 1 R4 被删除后，如果插入一个 ID=400 的行，可以复用这个位置的空间。但是如果插入的是 ID=800 的行，则不能复用这个位置了。</li><li>当整个页从 B+ 树摘掉以后，可以复用到任何位置。以图 1 为例，如果将数据页 page A 上的所有记录删除以后，page A 会被标记为复用。如果此时插入一条 ID=50 的记录需要使用新页的时候，page A 是可以被复用的。</li><li>如果相邻的两个数据页利用率较小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</li></ul><p><strong>因此如果用 delete 命令把整个表的数据删除，所有的数据页都会被标记可复用，但是磁盘上文件不会变小。</strong></p><p>这些可复用的，但是没有被使用的空间，看起来像是“空洞”。</p><p><strong>实际上，不止是删除数据会造成空洞，插入数据也会。</strong></p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，还可能造成索引的数据页分裂。</p><img src="/2019/03/17/数据库表的空间回收/插入数据导致页分裂.png" title="图2 插入数据导致页分裂"><p>从图 2 可以看到，由于 page A 满了，再插入一个 ID=550 的数据时，就不得不再申请一个新的页面 page B 来保存数据。页分裂完成后，page A 的末尾就留下了空洞。</p><p>另外更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。这也会造成空洞。</p><p>所以经过大量增删改查的表，都是有可能存在空洞的。如果能把这些空洞去掉就能达到收缩表空间的目的。</p><h4 id="重建表的方式"><a href="#重建表的方式" class="headerlink" title="重建表的方式"></a>重建表的方式</h4><p><strong>alter table A engine=InnoDB 命令来重建表</strong>。这个命令的执行流程相当于新建一个与表 A 结构相同的表 B，然后按照主键 ID 的顺序，一行一行的从表A 读出来再插入到表 B 中。MySQL 会自动完成转存数据、交换表名、删除旧表的操作。</p><img src="/2019/03/17/数据库表的空间回收/改锁表DDL.png" title="图3改锁表DDL"><p>显然花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写到表 A，就会造成数据丢失。因此整个 DDL 过程中，表 A 中不能有更新，也就是说这个 DDL 不是 Online 的。</p><p><strong>在 MySQL 5.6 版本开始引入 Online DDL，对这个操作流程做了优化。</strong></p><p>流程如下：</p><ol><li><p>建立一个临时文件，扫描表 A 主键的所有的数据页；</p></li><li><p>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</p></li><li><p>生成临时文件的过程中，将所有对 A 的操作记录记录在一个日志文件 (row log) 中，对应的是图中 state2 的状态；</p></li><li><p>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对用的是图中 state3 的状态；</p></li><li><p>用临时文件替换表 A 的数据文件。</p><img src="/2019/03/17/数据库表的空间回收/OnlineDDL.png" title="图4OnlineDDL"></li></ol><p>与图 3 过程的不同之处在于，由于日志文件记录和重放操作这个功能存在，这个方案在重建表的过程中，允许对表 A 做增删改查，这就是 Online DDL。</p><p>需要注意的是 alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。退化的目的，是为了实现 Online，MDL 读锁不会阻塞增删改查操作。</p><p>那为什么不直接解锁呢，那是为了保护自己，禁止其他线程同时对这个表做 DDL 。</p><p>对于一个大表，最费时间的是操作就是拷贝数据到临时表的过程。这个步骤的执行期间可以接受增删查改。所以相对整个 DDL 过程来说，锁的时间非常短。对于业务来说，就可以认为是 Online 的。</p><p><strong>Onilne 和 inplace</strong></p><p>在图 3 中，把表 A 中的数据导出来的存放位置叫做 tmp_table。这是一个临时表，是在 server 层创建的。</p><p>在图 4 中，根据表 A 重建出来的数据是放在“tmp_file” 里的，这个临时文件是 InnoDB 在内部创建出来的。整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地“操作，所以称之为 “inplace”。</p><p>所以重建表这个语句 alter table t engine=InnoDB 有隐藏意思：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>, ALGORITHM=inplace;</span><br></pre></td></tr></table></figure><p>跟 inplace 对应的就是拷贝表的方式，对应图 3 的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>, ALGORITHM=copy;</span><br></pre></td></tr></table></figure><p>所以Online 和 inplace 的关系：</p><ul><li>DDL 过程如果是 Online 的，就一定是 inplace 的</li><li>反过来未必。inplace 的 DDL，有可能不是 Online的。截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果要收缩一个表，只是 delete 掉表里面不用的数据的话，表文件的大小是不会变的，还要通过 alter table 命令重建表，才能达到表文件变小的目的。重建表具备两种实现方式，Online DDL 的方式是可以考虑在业务低峰期使用的，而 MySQL 5.5 及之前的版本，这个命令是会阻塞 DML 的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个 InnoDB 表包含两部分，即：表结构定义和数据。MySQL 8.0 版本以前，表结构是存在以 .frm 为后缀的文件里，而 8.0 版本 已经允许把表结构定义放在系统数据表中了。&lt;/p&gt;
&lt;h3 id=&quot;为什么简单地删除表数据达不到表空间回收的效果&quot;&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://stevenvww.github.io/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>全局锁和表锁</title>
    <link href="https://stevenvww.github.io/2019/03/15/%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/"/>
    <id>https://stevenvww.github.io/2019/03/15/%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/</id>
    <published>2019-03-15T08:49:05.000Z</published>
    <updated>2020-01-10T10:30:13.541Z</updated>
    
    <content type="html"><![CDATA[<p>根据加锁的范围，MySQL 分为全局锁、表级锁和行锁三类。</p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是针对整个数据库实例加锁。</p><p>MySQL 提供加全局读锁的方法：Flush tables with read lock(FTWRL)。</p><p>解锁的方法：unlock tables</p><p>这个命令可以使整个库处于只读状态，而数据更新语句，数据定义语句和更新类事务的提交语句将全部被阻塞。</p><p>典型使用场景：做全库逻辑备份。</p><p>全库只读的<strong>风险：</strong></p><ul><li>如果在主库备份，备份期间都不能执行更新，业务基本停止。</li><li>如此在从库备份，备份期间从库不能执行主库同步过来的 binlog ，会导致主从延迟。</li></ul><p>使用官方自带的逻辑备份工具 mysqldump，只要加上参数 <strong>–single-transaction</strong>，导数据前会启动一个事务，来确保拿到一致性视图，由于 MVVC 的支持，这个过程中可以正常更新。<strong>一致性读确实很好，但前提必须引擎要支持这个隔离级别</strong>。比如，对于 MyISAM 这种不支持事务的引擎，只能使用 FTWRL 。</p><p><strong>所以，single-transaction 方法只适合所有的表使用事务引擎的库。</strong></p><p>使用 set global readonly=true 也可以让全库进入只读状态。<strong>但是还是不推荐使用，原因如下：</strong></p><ul><li>有些系统，readonly 的值被用来做其他逻辑。例如，用来判断一个库是主库还是从库。因此修改 global 变量影响更大，不建议使用。</li><li>在异常处理机制有差异。如果执行 FTWRL 命令后客户端发送异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设为 readonly 之后，如客户端发送异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级别的锁有两种：一种是表锁，一种是元数据锁 (meta data lock, MDL)</p><h4 id="表锁-lock-tables-…-read-write"><a href="#表锁-lock-tables-…-read-write" class="headerlink" title="表锁 (lock tables … read/write)"></a>表锁 (lock tables … read/write)</h4><p>可以使用 unlock tables 主动解锁，也可以在客户端断开的时候自动释放。lock tables 语法除了会限制别的线程读写外，也限定了本线程接下来的操作对象。</p><p>在没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面很大。</p><h4 id="MDL-锁"><a href="#MDL-锁" class="headerlink" title="MDL 锁"></a>MDL 锁</h4><p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保持读写的正确性。可以想象一下，如果一个查询在遍历一个表中的数据，执行期间另一个线程对这个表结构做变更，删除一列，那么多拿到的结果对不上，肯定不行。</p><p>因此，在 MySQL 5.5 版本引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当对表做结构变更的时候，加 MDL 写锁。</p><ul><li>读锁之间不互斥，可多线程同事对一张表之间增删改查</li><li>读写锁之间，写锁之间互斥，用来保证变更表结构操作的安全性。所以如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p><strong>ＭDL 锁有一个机制，MDL 会直到事务提交才释放，在做表结构变更的时候，可能会一不小心锁住线上查询和更新</strong>。</p><p>假设我们有个表 t，我们要做如下操作：</p>   <img src="/2019/03/15/全局锁和表锁/MDL死锁操作.jpg" title="MDL死锁操作"><p>由图可知：</p><ul><li>session A 先启动，这时会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行</li><li>session C 会被 blocked，因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁。</li><li>如果在 session C 之后还要对表t新申请 MDL 读锁的请求，会被 session C 阻塞。这就导致整个表都被锁住了，等于这个表完全不可读写了。</li><li>如果某个表上的查询语句频繁，而且客户端有重制机制，这个库的线程很快就会爆满。</li></ul><p><strong>那么怎么给一个小表加字段呢？</strong></p><ul><li><p>先解锁长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，可以查到当前执行的事务。如果要做 DDL 变更刚好有长事务执行，可以考虑先暂停 DDL, 或者 kill 掉这个长事务。</p></li><li><p>假设是个热点表，请求频繁。可以在 alter table 语句设置等待时间，如果在指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员再通过重试命令重复这个过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">NOWAIT</span> <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据加锁的范围，MySQL 分为全局锁、表级锁和行锁三类。&lt;/p&gt;
&lt;h3 id=&quot;全局锁&quot;&gt;&lt;a href=&quot;#全局锁&quot; class=&quot;headerlink&quot; title=&quot;全局锁&quot;&gt;&lt;/a&gt;全局锁&lt;/h3&gt;&lt;p&gt;全局锁就是针对整个数据库实例加锁。&lt;/p&gt;
&lt;p&gt;MySQ
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://stevenvww.github.io/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>刷脏页机制</title>
    <link href="https://stevenvww.github.io/2019/03/13/%E5%88%B7%E8%84%8F%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    <id>https://stevenvww.github.io/2019/03/13/%E5%88%B7%E8%84%8F%E9%A1%B5%E6%9C%BA%E5%88%B6/</id>
    <published>2019-03-13T02:00:25.000Z</published>
    <updated>2020-01-10T10:30:13.543Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是脏页？"><a href="#什么是脏页？" class="headerlink" title="什么是脏页？"></a>什么是脏页？</h3><p>InnoDb 在执行更新语句的时候，是先写日志(redo log)，再更新内存，然后告诉客户端更新完成了。此时内存和磁盘的数据是不一致的。<br><strong>所以当内存数据页跟磁盘数据页不一致的时候，称这个内存也为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容一致的时候，称之为“干净页”</strong>。</p><h3 id="什么时候刷脏页？"><a href="#什么时候刷脏页？" class="headerlink" title="什么时候刷脏页？"></a>什么时候刷脏页？</h3><p>将内存上的数据写入到磁盘，称为刷脏页(flush)。</p><p>以下 MySQL 可能刷脏页的时机：</p><ol><li><p>InnoDB redo log 写满了。这时候系统会停止所有的更新操作，把 checkpoint 往前推进，redo log 留出空间继续写。下图展示了 checkpoint 从 CP 推进到 CP’，需要将两点的日志，对应的脏页全部 flush 到磁盘上。</p><img src="/2019/03/13/刷脏页机制/redolog状态图.jpg" title="redolog状态图"></li><li><p>系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。但不会直接淘汰内存，因为刷脏页必定写盘，写盘就保证了数据页只有两种状态：</p><ul><li>一种是内存里存在，内存里肯定是最正确的结果，直接返回</li><li>另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样效率最高。</li></ul></li><li><p>MySQL 认为系统“空闲”的时候。MySQL 会利用空闲时间刷脏页，见缝插针。</p></li><li><p>MySQL 正常关闭的时候。这时 MySQL 会将所有的脏页都 flash 到磁盘上，这样下次启动 MySQL 的时候，就可以直接从磁盘读取数据，启动速度会很快。</p></li></ol><p><strong>四种场景对性能的影响</strong></p><ul><li><p>第一种 “redo log 写满了，要 flush 脏页”。这种情况 InnoDB要尽量避免的。因为这出现这种情况的时候，整个系统都不能再接受更新了，所有的更新必须堵住。</p></li><li><p>第二种 ”内存不够用了，要先将脏页写进磁盘“。这种情况是常态。<strong>InnoDB 用缓冲池 (buffer pool) 管理内存，缓冲池中的内存页有三种状态：</strong></p><ul><li>第一种，还没有使用</li><li>第二种，使用了并且是干净页</li><li>第三种，使用了并且是脏页</li></ul><p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p><p>当要读入的数据页没有在内存的时候，就必须要缓冲池申请一个数据页。这时候只能将最久不使用的数据页从内存中淘汰掉；如果是要淘汰一个干净页，就直接释放出来复用；但如果是脏页，就必须将脏页先刷到磁盘，变成干净页才能复用。</p><p>所以刷脏页虽然是常态，但是出现以下两种情况，都是会明显影响性能的：</p><ol><li>一个查询要淘汰的脏页过多，会导致查询的响应时间明显变长。</li><li>日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务是不能接受的。</li></ol><p>所以需要有控制脏页比例的机制，来避免以上两种情况。</p></li></ul><h3 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h3><ol><li><p>正确告诉 InnoDB 所在主机的 IO 能力。通过设置 innodb_io_capacity 参数，告诉 InnoDB 磁盘能力。这个值建议设置为磁盘的 IOPS。可以使用 fio 工具测试磁盘的随机读写的能力。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio <span class="attribute">-filename</span>=<span class="variable">$filename</span> <span class="attribute">-direct</span>=1 -iodepth 1 -thread <span class="attribute">-rw</span>=randrw <span class="attribute">-ioengine</span>=psync <span class="attribute">-bs</span>=16k <span class="attribute">-size</span>=500M <span class="attribute">-numjobs</span>=10 <span class="attribute">-runtime</span>=10 -group_reporting <span class="attribute">-name</span>=mytest</span><br></pre></td></tr></table></figure></li><li><p>控制 InnoDB 刷盘速度。InnoDB 是根据脏页比例、redo log 写盘速度来控制刷脏页的速度。</p><p>InnoDB 会根据两个因素单独先算出两个数字。</p><p>参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75% 。InnoDB 会根据当前的脏页比例 (假设为M) ，算出一个范围在0~100之间的数组，计算这个数据伪码如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，假设为N。</p><p>InnoDB 会根据 N 算出在 0~100的数字，这个计算公式记为 F2(N)。F2(N) 算法复杂，但是 N 越大，算出来的值越大。</p><p><strong>然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R ，之后引擎可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制脏页的速度。</strong></p></li></ol><p>InnoDB 会在后台刷脏页，而刷脏页的过程是将内存页写入磁盘。所以无论是查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到更新语句，都可能造成从业务端感知数据库突然变慢。</p><p><strong>要尽量合理避免这种情况，就要合理设置 Innodb_io_capacity 的值，并且平时要多关注脏页比例，不要让它接近于 75%</strong></p><p>脏页比例是通过 Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total 得到的，具体代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_dirty'</span>;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_total'</span>;</span><br><span class="line"><span class="keyword">select</span> @a/@b;</span><br></pre></td></tr></table></figure><p><strong>“连坐”策略</strong></p><p>InnoDB 在刷脏页的时候，如果发现当前数据页旁边的那个数据页也是脏页，就会连带着一起刷掉；这种情况会蔓延，如果邻居的邻居也是脏页，也会一起刷。</p><p>在 InnoDB 中，Innodb_flush_neighbors 参数可以控制该行为，值为1的时候会有上述”连坐”机制，值为0的时候表示自己刷自己的，不帮邻居刷了。</p><p>找“邻居”这种行为，在机械硬盘时代很有意义，可以减少很多随机IO。现在如果使用 SSD 或者 IOPS 比较高的设备，建议将 Innodb_flush_neithbors 设为0，在 MySQL 8.0 已经默认为 0。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是脏页？&quot;&gt;&lt;a href=&quot;#什么是脏页？&quot; class=&quot;headerlink&quot; title=&quot;什么是脏页？&quot;&gt;&lt;/a&gt;什么是脏页？&lt;/h3&gt;&lt;p&gt;InnoDb 在执行更新语句的时候，是先写日志(redo log)，再更新内存，然后告诉客户端更新完成了。此
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://stevenvww.github.io/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-更新语句怎么执行的</title>
    <link href="https://stevenvww.github.io/2019/03/05/MySQL-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://stevenvww.github.io/2019/03/05/MySQL-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84/</id>
    <published>2019-03-05T09:56:41.000Z</published>
    <updated>2020-01-10T10:30:13.523Z</updated>
    
    <content type="html"><![CDATA[<p>假设有个表T，创建语句如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table <span class="constructor">T(ID <span class="params">int</span> <span class="params">primary</span> <span class="params">key</span>, <span class="params">c</span> <span class="params">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>将 ID=2 这一行的值加2：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">update</span> T <span class="keyword">set</span> c=c+<span class="number">1</span> <span class="keyword">where</span> ID = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><img src="/2019/03/05/MySQL-更新语句怎么执行的/MySQL逻辑架构图.png" title="MySQL逻辑架构图"><p>该语句基本的执行链路如下：</p><ol><li>连接数据库，连接器会处理</li><li>分析器会通过词法和语法分析知道这是一条更新语句</li><li>优化器决定使用 ID 这个索引</li><li>执行器进行具体执行，找到这一行，然后更新</li></ol><p>以上只是基本链路，MySQL 执行更新还涉及两个日志模块，分别是 redolog 和 binlog。</p><h3 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log (重做日志)"></a>redo log (重做日志)</h3><p>在《孔乙己》这篇文章中，酒店掌柜有个专门的黑板来记录客人的赊账记录。如果赊账的人多，他会记在黑板上，如果赊账的人过多，黑板总会记不下，掌柜一定得擦掉黑板，把赊账的记录写入专门记录赊账的记账本。</p><p>如果有人赊账或还帐，掌柜一般有两种做法：</p><ul><li>直接记录在账本上</li><li>先记录在黑板上，等空闲了再记录到账本上</li></ul><p>如果店里的人很多，掌柜还直接记录在账本上，那么效率一定很低，非常耽误生意。因此掌柜肯定会选择第二种做法。</p><p>在 MySQL 中也有这样的问题，如果每次更新操作都需要写进磁盘，然后磁盘也要找到对应的记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决此问题，MySQL设计者就用了类似酒店掌柜黑板的思路来提升更新效率。</p><p>在 MySQL 中，redolog 就充当了黑板的角色，磁盘就是账本的角色。通过先写日志，再写磁盘来提升更新效率。其实这也是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead-Logging。</p><p>具体来将，当有一条记录需要更新的时候：</p><ul><li>InnoDB 引擎先将记录写到 redo log 里面，并更新内存，这个时候就算更新完了</li><li>InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里</li></ul><p>redo log 是固定大小的，比如可以配置成为一组 4 个文件，每个文件大小是 1GB，那么可以记录 4GB 的操作。从头开始写，写到末尾又回到开头循环写。如下图所示。</p><img src="/2019/03/05/MySQL-更新语句怎么执行的/redolog循环写.png" title="redolog循环写"><ul><li>wirte pos 是当前记录的位置，边写边后移，写到 3 号文件末尾后就回到 0 号文件开头。</li><li>checkpoint 是当前要擦除的位置，也是往后移并循环的，擦除记录前要将记录更新到数据文件。</li><li>write pos 和 checkpoint 之间是空着的部分，可以用来记录新的操作。</li><li>如果 write pos 追上了 checkpoint，表示 redo log 满了，这时候不能执行新的更新，得停新来先擦掉一些记录，把 checkpoint 推进一下。</li></ul><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个叫 <strong>crash-safe。</strong></p><h3 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog (归档日志)"></a>binlog (归档日志)</h3><p>MySQL 整体看来，其实就两块：</p><ul><li>一块是 Server 层，主要做的是 MySQL 功能层面的事情；</li><li>一块是引擎层，负责存储相关的事宜。</li></ul><p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog</p><p>这两种日志有以下三种不同：</p><ul><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有的引擎都可以用。</li><li>redo log 是物理日志，记录的是 “在这个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如 “给 ID=2 这一行的 c 字段加 1”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。”追加写” 是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><p>所以执行器和 InooDB 引擎在执行简单的 update 语句时内部流程如下。</p><img src="/2019/03/05/MySQL-更新语句怎么执行的/执行update.png" title="执行update"><ol><li>执行器先找到引擎 ID= 2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎借口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告诉执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并将 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交 (commit) 状态，更新完成。</li></ol><p>由上可知，最后是三步将 redo log 的写入拆成了两个步骤：prepare 和 commit。这就是“两阶段提交”。</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>目的：是为了让两份日志之间的逻辑一致。</p><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么先写 redo log，要么先写 binlog，会出现以下状况。(仍然用前面的例子)</p><ol><li><p><strong>先写 redo log 后写 binlog。</strong>假设写完了 redo log，binlog 还没写完崩溃，MySQL 异常重启。由于 redo log有崩溃恢复数据的能力，所以恢复后 c 的值仍然是 1 。<br>但是由于 binlog 没写完就 crash 了，这个时候 binlog 里面就没有记录这个语句。因此之后备份日志的时候，存起来的 binlog 没有这条语句。<br>然后如果用这个 binlog 恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原酷的值不同。</p></li><li><p><strong>先写 binlog 后写 redo log。</strong>如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了 “把 c 从 0 改为 1”这个日志。所以之后 binlog 来恢复的时候就多了一个事务，恢复出来的 c 的值就是 1，与原库的值不同。</p></li></ol><p>由上可知，不使用两阶段提交，那么数据库状态有可能和它的日志恢复出来的库状态不一致。<br>redo log 和 binlog 都可以用于表示事务提交的状态，而两阶段提交就是让两个状态保持逻辑上的一致。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设为 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。建议设为 1，可以保证 MySQL 异常重启之后数据不丢失。</li><li>sync_binlog 这个参数设为 1 的时候，表示每次事务的 binlog 都持久化到磁盘。同样建议设为 1，可以保证 MySQL 异常重启后数据不丢失。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设有个表T，创建语句如下：&lt;/p&gt;
&lt;figure class=&quot;highlight reasonml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td cl
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://stevenvww.github.io/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-字符串加索引的方法</title>
    <link href="https://stevenvww.github.io/2019/03/01/MySQL-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://stevenvww.github.io/2019/03/01/MySQL-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2019-03-01T09:32:33.000Z</published>
    <updated>2020-01-10T10:30:13.521Z</updated>
    
    <content type="html"><![CDATA[<p>假设要维护一个支持邮箱登录的系统，用户表如下定义：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">create</span> table SUser(</span><br><span class="line">ID bigint unsigned <span class="keyword">primary</span> <span class="keyword">key</span>,</span><br><span class="line">email varchar(<span class="number">64</span>), </span><br><span class="line">... </span><br><span class="line">)engine=innodb;</span><br></pre></td></tr></table></figure><p>由于使用邮箱登录，登录的时候一定要根据邮箱去查询。所以业务代码一定会出现一下语句：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> ID, email <span class="keyword">from</span> SUser <span class="keyword">where</span> email=<span class="string">'zhangssxyz@xxx.com'</span>;</span><br></pre></td></tr></table></figure><p>因此 email 字段必须加上索引，否则这个语句会做全表扫描。</p><h3 id="１．完整索引"><a href="#１．完整索引" class="headerlink" title="１．完整索引"></a>１．完整索引</h3><p>直接给 email 字段加上索引</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alert <span class="keyword">table</span> Suser <span class="comment">add index index1(email)</span>;</span><br></pre></td></tr></table></figure><p>该语句创建的 index1 索引，包含了每个记录的整个字符串，索引示意图如下：</p><img src="/2019/03/01/MySQL-字符串加索引的方法/完整索引.jpg" title="完整索引示意图"><p><strong>index1 执行顺序如下：</strong></p><ul><li>从 index1 索引树找到满足索引值是 <a href="mailto:&#39;zhangssxyz@xxx.com" target="_blank" rel="noopener">&#39;zhangssxyz@xxx.com</a>‘ 的记录，取得 ID2的值；</li><li>到该主键上插到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集；</li><li>取 index1 索引树上刚刚查到的位置的下一条记录，发现不满足 <a href="mailto:email=&#39;zhangssxyz@xxx.com" target="_blank" rel="noopener">email=&#39;zhangssxyz@xxx.com</a>‘ 的条件，循环结束。</li></ul><p>这个过程中，只需要回主键索引取一次记录，所以系统只认为扫描了一行。</p><h3 id="２．-前缀索引"><a href="#２．-前缀索引" class="headerlink" title="２． 前缀索引"></a>２． 前缀索引</h3><p>将某个字段的前ｎ位设为索引，下面语句创建 email(6) 索引结构</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alert <span class="keyword">table</span> SUser <span class="comment">add index index2(email(6))</span>;</span><br></pre></td></tr></table></figure><p>该语句创建的 index2 索引，对于每个记录只取了６个字节，索引示意图如下：</p><img src="/2019/03/01/MySQL-字符串加索引的方法/前缀索引.jpg" title="前缀索引示意图"><p><strong>index2 执行顺序如下：</strong></p><ul><li>从 index2 索引树找到满足索引值是 ‘zhangs’ 的记录，找到第一个是 ID1;</li><li>到主键上查到主键值是 ID1 的行，判断 email 的值不是 <a href="mailto:&#39;zhangssxyz@xxx.com" target="_blank" rel="noopener">&#39;zhangssxyz@xxx.com</a>‘，这行丢弃</li><li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是 ‘zhangs’, 取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，直到在 index2 上取到的值不是 ‘zhangs’ 时，循环结束。</li></ul><p>这个过程中，要回主键索引取 4 次判断，也就是扫描了 4 行。</p><p>通过对比，可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。</p><p>但是，对于这个查询语句来说，如果定义的 index2 不是 email(6) 而是 email(7)，也就是说取 email 字段前７个字节来构建索引的话，即满足前桌 ‘zhangs’ 的记录只有一个，也能够直接插到 ID2，只扫描一行就结束了。</p><p>也就是说<strong>使用前缀索引，定义好长度就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p><p><strong>如何确认前缀索引的长度？</strong></p><p>答案：区分度，区分度越高意味着重复值的键值越少。因此可以统计索引有多少不同的值来判断要使用多长的前缀。</p><p>首先，使用下面这个语句，算出这个列上有多少不同的值：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> SUser;</span><br></pre></td></tr></table></figure><p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7 个值字节的前缀索引：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span></span><br><span class="line">true<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">4</span>) <span class="keyword">as</span> L4)</span><br><span class="line">true<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">5</span>) <span class="keyword">as</span> L5)</span><br><span class="line">true<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">6</span>) <span class="keyword">as</span> L6)</span><br><span class="line">true<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">7</span>) <span class="keyword">as</span> L7)</span><br><span class="line"><span class="keyword">from</span> Suser;</span><br></pre></td></tr></table></figure><p>使用前缀索引很有可能损失区分度，所以需要预先设定一个损失比例，比如 5%。然后在返回的 L4~L7 中，找出不小于 L*95% 的值，假设这里 L6、L7 都满足，可以选择前缀长度为6。</p><p><strong>前缀索引对覆盖索引的影响</strong></p><p>前缀索引不仅仅可能会增加扫描行数，还有可能影响性能。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> id,email <span class="keyword">from</span> SUser <span class="keyword">where</span> email =<span class="string">'zhangssxyz@email.com'</span>;</span><br></pre></td></tr></table></figure><p>以上这个语句仅仅返回 id 和 email 字段。</p><p>所以，如果使用 index1 的话，可以利用覆盖索引，从 index1 查询到结果直接返回即可，无需回到 ID 索引再去查一次。而如果使用 index2 的话，就不得不回到 ID 索引再去判断 email 字段的值。</p><p>即使将 index2 的定义修改为 email(18) 的前缀索引，这时候虽然 index2 包含了所有的信息，但是 InnoDB还是要回到 ID 索引再查一次，因为系统并不确定前缀索引的定义是否截断了完整信息。</p><p>也就是说，<strong>使用前缀索引就用不上覆盖索引对查询性能的优化。</strong></p><h3 id="3-其他方式"><a href="#3-其他方式" class="headerlink" title="3. 其他方式"></a>3. 其他方式</h3><p>对于邮箱这样的字段来说，使用前缀索引的效果可能还不粗，但是遇到前缀的区分度不够好的情况，该怎么办？</p><p>比如，身份证号码，共 18 位，其中前 6 位是地址码，所以同一个县的人身份证号前6位一般是相同的，因此如果对身份证号做长度为6的前缀索引，区分度极低。</p><p>按照前面的方法，可能需要创建长度为12以上的前缀索引，才能满足区分度要求。但是索引选取的越长，占用的磁盘空间越大，相同的数据页能放下的索引的值越少，搜索效率也越低。</p><p>那么如果确认业务需求只按照身份证号进行等值查询的需求，可以使用以下方法</p><p><strong>第一种倒序存储</strong> (如果存储身份证号码的时候把它倒过来存，每次查询可以这么写)</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card = <span class="keyword">reverse</span>(<span class="string">'input_id_card_string'</span>);</span><br></pre></td></tr></table></figure><p>由于身份证最后6位没有地址码这样重复的逻辑，最后6位很有可能提供了足够的区分度，</p><p><strong>第二种使用 hash 字段</strong> (在表上再创建一个整数字段，来保存身份证的校验码，同事在这个字段上创建索引)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> id_card_crc <span class="type">int</span> unsigned, <span class="keyword">add</span> <span class="keyword">index</span>(id_card_crc);</span><br></pre></td></tr></table></figure><p>然后每次插入新记录的时候，都使用 crc32() 这个函数得到校验码填到这个新字段，由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32() 函数得到的结果可能是相同的，所以查询语句 where 部分要判断 id_card 的值是否精确相同。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list <span class="keyword">from</span> t where <span class="attribute">id_card_crc</span>=crc32('input_id_card_string') <span class="keyword">and</span> <span class="attribute">id_card</span>=<span class="string">'input_id_card_string'</span>;</span><br></pre></td></tr></table></figure><p>这样索引长度变成了 4 个字节，比原来小了很多。</p><p><strong>两种方法的异同点</strong></p><p>同：</p><ul><li>不支持范围查询，只支持等值查询</li></ul><p>异：</p><ul><li>占用空间上，倒序存储方式在主键索引上不会消耗额外的存储空间，而 hash 字段防范需要增加一个字段。</li><li>CPU 消耗方面，倒序方式每次读写，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果从两个函数的计算复杂度来看的话， reverse 函数额外消耗的 CPU 资源会更小点。</li><li>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行接近1。而倒序存储的方式毕竟还是用的前缀索引的方式，也就是说会增加扫描行数。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>字符串字段创建索引总共有4种方式</p><ol><li>直接创建完整索引，这样可能比较占用空间；</li><li>创建前缀索引，节省空间，但是会增加查询扫描次数，并且不能使用覆盖索引</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题</li><li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设要维护一个支持邮箱登录的系统，用户表如下定义：&lt;/p&gt;
&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
    
      <category term="MySQL45讲学习笔记" scheme="https://stevenvww.github.io/tags/MySQL45%E8%AE%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Inversion of Control</title>
    <link href="https://stevenvww.github.io/2018/01/03/Inversion-of-Control-Container/"/>
    <id>https://stevenvww.github.io/2018/01/03/Inversion-of-Control-Container/</id>
    <published>2018-01-03T09:27:22.000Z</published>
    <updated>2020-01-10T10:30:13.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC" target="_blank" rel="noopener">Inversion of Control</a> 中文翻译为“控制反转”，是面向对象编程中的一种设计原则。用来降低程序代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中</p></blockquote><h2 id="理解控制反转"><a href="#理解控制反转" class="headerlink" title="理解控制反转"></a>理解控制反转</h2><p>假设有个老板需要一个才华特别好的人帮助他做事，于是直接命令小张帮忙。示例如下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类 A 需要用到类 B。直觉做法。</span></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue$b = <span class="keyword">new</span> B();</span><br><span class="line">truetrue$b-&gt;doSomething();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">XiaoZhang</span> </span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue<span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老板果然牛逼，老板直接控制小张干活。但是有一点不好的在于，如果小张跑路了咋办呢？为了解决这个问题，老板特地建了一个人才库，由人才库向老板输出人才，来完成事物。</p><p>由此可知：</p><ul><li>老板直接控制小张干活，即在代码中体现为应用程序主动寻求外部资源，应用程序是老大。</li><li>老板等待人才库注入人才。即在代码中 IoC 容器先获取需要的实例，然后再反向注入到应用程序。应用程序被动等待。</li><li>老板由主动转为被动，即为控制反转。</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于接口实现依赖注入，老板不再依赖小张</span></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">(niuren $b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue$b-&gt;doSomething();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">niuren</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">XiaoZhang</span> <span class="title">implement</span> <span class="title">niuren</span></span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue<span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖查找"><a href="#依赖查找" class="headerlink" title="依赖查找"></a>依赖查找</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用容器等控制系统，主动解析获取对象</span></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">(B $b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue$b-&gt;doSomething();</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">XiaoZhang</span> </span>&#123;</span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">truetrue<span class="keyword">echo</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">true<span class="comment">//获取实例</span></span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">true<span class="comment">//绑定实例</span></span><br><span class="line">true<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span><span class="params">($abstract, $contern)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$container = <span class="keyword">new</span> Container();</span><br><span class="line">$container-&gt;bind(<span class="string">'xz'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> <span class="keyword">new</span> XiaoZhang();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$xiaozhang = $container-&gt;get(<span class="string">'xz'</span>);</span><br><span class="line"></span><br><span class="line">$boss = <span class="keyword">new</span> Boss();</span><br><span class="line">$boss-&gt;doSomething($xiaozhang);![]()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上两种方法都是为了代码解耦。</p><ul><li>依赖注入不需要了解自身依赖具体哪个类，只要所依赖的类实现了自身需要的方法即可。</li><li>依赖查找即提供一种调控系统，实现依赖解析、依赖注入、依赖绑定。</li></ul>]]></content>
    
    <summary type="html">
    
      关于控制反转的笔记
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PHP 自动加载分析</title>
    <link href="https://stevenvww.github.io/2017/12/21/PHP-Auto-Loader/"/>
    <id>https://stevenvww.github.io/2017/12/21/PHP-Auto-Loader/</id>
    <published>2017-12-21T06:54:07.000Z</published>
    <updated>2020-01-10T10:30:13.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人主要总结 PHP 自动加载的功能，内容涉及 SPL 函数库，PSR 标准，Composer 自动加载。</p><hr><h3 id="PHP-自动加载功能"><a href="#PHP-自动加载功能" class="headerlink" title="PHP 自动加载功能"></a>PHP 自动加载功能</h3><blockquote><p>自动加载是指，PHP 解释器在运行时按需自动找到并加载 PHP 类的过程。</p></blockquote><h4 id="为什么需要自动加载功能"><a href="#为什么需要自动加载功能" class="headerlink" title="为什么需要自动加载功能"></a>为什么需要自动加载功能</h4><p>PHP5 后，PHP完全支持面向对象编程。在面向对象编程中，开发者必须为每个类都建立一个 PHP 文件。这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类都有个文件）。</p><h4 id="autoload-魔术方法-（PHP-7-2-废止）"><a href="#autoload-魔术方法-（PHP-7-2-废止）" class="headerlink" title="__autoload( ) 魔术方法 （PHP 7.2 废止）"></a>__autoload( ) 魔术方法 （PHP 7.2 废止）</h4><p>为了避免每个类文件都要 include/require 一大串类，PHP5 之后提供了类的自动加载机制(autoloader)。<br>这种加载机制有以下几个优点。</p><blockquote><ol><li>用户可以有需要再加载类，而不是一开始就全部加载进来。</li><li>无需考虑类的文件地址，实现了逻辑与文件分离。</li></ol></blockquote><p>PHP5 后，当加载 PHP 类时，如果类所在的文件没有被包含或类名出错，Zend引擎会自动调用 <a href="http://php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload( )</a> 函数来加载。此函数需要用户自己实现。下面是个简单的例子。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__autoload( ) 使用实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true$fileName = <span class="string">"./"</span> . $className . <span class="string">".php"</span>;</span><br><span class="line">true<span class="keyword">include_once</span>($fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个简单的例子可知，__autoload( ) 函数讲类名和文件名对应起来，两者最重要的是类名和文件的映射规则。</p><h4 id="spl-autoload-register-方法"><a href="#spl-autoload-register-方法" class="headerlink" title="spl_autoload_register( ) 方法"></a>spl_autoload_register( ) 方法</h4><blockquote><p>做项目时我们引入大量的第三方库，每个库都有自己的映射规则。如果要实现自动加载，__autoloader( ) 函数必须实现每条规则，由于函数全局唯一的特性，这将导致函数臃肿、难以维护、容易出错。</p></blockquote><p>为了解决这个问题，PHP 提供了 <a href="http://php.net/manual/zh/function.spl-autoload-register.php" target="_blank" rel="noopener">sql_autoload_register()</a> 函数，该函数支持任意数量的自动加载器，所有的自动加载器都存放在autoload 函数的队列内。当 PHP 找不到类名，PHP 会自动调用这个队列，执行队列内的自定义的 __autoloader() 函数，实现自动加载功能。</p><h4 id="PSR-4-自动加载器策略"><a href="#PSR-4-自动加载器策略" class="headerlink" title="PSR-4 自动加载器策略"></a>PSR-4 自动加载器策略</h4><blockquote><p>PSR 是 PHP Standards Recommendation 的简称。PSR- 开头，后面+一个数字。都是 PHP-FIG 制定的推荐规范，用于解决大多数 PHP 框架经常会遇到的某个具体问题。 PHP 框架无需频繁解决相同的问题，大家只需使用共同的方案解决。</p></blockquote><blockquote><p>如今，现代的 PHP 组件和框架都符合同一个自动加载标准。这意味着我们只需一个自动加载器就能混合搭配多个PHP组件。</p></blockquote><blockquote><p>PSR-4 用于在运行时查找并加载 PHP 类、接口和性状。只建议如何使用文件系统目录结构和 PHP 命名空间组织代码。</p></blockquote><p>PSR-4的精髓是把命名空间的前缀和文件系统中的目录对应起来。举例如下。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设<span class="symbol">\O</span>reilly<span class="symbol">\M</span>odernPHP命名空间中的类在物理文件系统的src/目录中</span><br><span class="line"></span><br><span class="line">"<span class="symbol">\O</span>reilly<span class="symbol">\M</span>odernPHP" =&gt; "src/"</span><br><span class="line"></span><br><span class="line">"<span class="symbol">\O</span>reilly<span class="symbol">\M</span>odernPHP<span class="symbol">\C</span>hapter1<span class="symbol">\E</span>xample" =&gt; "src/Chapter1/Example.php"</span><br><span class="line"></span><br><span class="line">命名空间的前缀可以是顶级命名空间，也可以是顶级命名空间+任意一个子命名空间</span><br></pre></td></tr></table></figure><p>由上可知命名空间前缀对应于文件系统的基目录，命名空间前缀的子命名空间对应这个基目录的子目录。</p><p>接下我们看看PSR-4 自动加载器的示例代码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line">/**</span><br><span class="line"> * 举例说明如何实现项目专用的自动加载器</span><br><span class="line"> * </span><br><span class="line"> * 使用 SPL 注册这个自动加载函数后，遇到下述代码时这个函数</span><br><span class="line"> * 会尝试从 /path/to/project/src/Baz/Qux.php 文件中加载</span><br><span class="line"> * </span><br><span class="line"> * \Foo\Bar\Baz\Qux 类</span><br><span class="line"> *  new \Foo\Bar\Baz\Qux;     </span><br><span class="line"> *  </span><br><span class="line"> * @param string $class 完全限定的类名</span><br><span class="line"> * @return void</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php">spl_autoload_register(<span class="function"><span class="keyword">function</span> <span class="params">($class)</span> </span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 项目的命名空间前缀</span></span></span><br><span class="line"><span class="php">    $prefix = <span class="string">'Foo\\Bar\\'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 基目录</span></span></span><br><span class="line"><span class="php">    $base_dir = <span class="keyword">__DIR__</span> . <span class="string">'/src/'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 参数传入的类使用这个命名空间前缀吗?</span></span></span><br><span class="line"><span class="php">    $len = strlen($prefix);</span></span><br><span class="line"><span class="php">    <span class="keyword">if</span> (strncmp($prefix, $class, $len) !== <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="php">        <span class="comment">// 不使用交给下一个自动加载器处理</span></span></span><br><span class="line"><span class="php">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 获取去掉前缀后的类名</span></span></span><br><span class="line"><span class="php">    $relative_class = substr($class, $len);</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 把命名空间前缀替换成基目录</span></span></span><br><span class="line"><span class="php">    <span class="comment">// 在去掉前缀的类名中，把命名空间分隔符替换成目录分隔符</span></span></span><br><span class="line"><span class="php">    <span class="comment">// 然后在后面加上.php</span></span></span><br><span class="line"><span class="php">    $file = $base_dir . str_replace(<span class="string">'\\'</span>, <span class="string">'/'</span>, $relative_class) . <span class="string">'.php'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="comment">// 如存在，导入</span></span></span><br><span class="line"><span class="php">    <span class="keyword">if</span> (file_exists($file)) &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">require</span> $file;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;);</span></span><br></pre></td></tr></table></figure><hr><p>以上可知现代 PHP 自动加载策略的实现是由PSR-4 规范 + SPL 函数库共同构建。我们编写的 PSR-4 自动加载器虽然可用，但是我们自己没必要如此做。因为我们可以使用依赖管理器 Composer 自动生成的 PSR-4 自动加载器。</p>]]></content>
    
    <summary type="html">
    
      关于 PHP 自动加载的笔记
    
    </summary>
    
    
    
      <category term="PHP学习笔记" scheme="https://stevenvww.github.io/tags/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
